/*!
 * SPDX-License-Identifier: Unlicense
 * This file was automatically generated by https://github.com/yt-dlp/ejs
 */
var jsc = (function (meriyah, astring) {
  "use strict";
  function matchesStructure(obj, structure) {
    if (Array.isArray(structure)) {
      if (!Array.isArray(obj)) {
        return false;
      }
      return (
        structure.length === obj.length &&
        structure.every((value, index) => matchesStructure(obj[index], value))
      );
    }
    if (typeof structure === "object") {
      if (!obj) {
        return !structure;
      }
      if ("or" in structure) {
        return structure.or.some((node) => matchesStructure(obj, node));
      }
      if ("anykey" in structure && Array.isArray(structure.anykey)) {
        const haystack = Array.isArray(obj) ? obj : Object.values(obj);
        return structure.anykey.every((value) =>
          haystack.some((el) => matchesStructure(el, value)),
        );
      }
      for (const [key, value] of Object.entries(structure)) {
        if (!matchesStructure(obj[key], value)) {
          return false;
        }
      }
      return true;
    }
    return structure === obj;
  }
  function isOneOf(value, ...of) {
    return of.includes(value);
  }
  function _optionalChain(ops) {
    let lastAccessLHS = undefined;
    let value = ops[0];
    let i = 1;
    while (i < ops.length) {
      const op = ops[i];
      const fn = ops[i + 1];
      i += 2;
      if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
        return undefined;
      }
      if (op === "access" || op === "optionalAccess") {
        lastAccessLHS = value;
        value = fn(value);
      } else if (op === "call" || op === "optionalCall") {
        value = fn((...args) => value.call(lastAccessLHS, ...args));
        lastAccessLHS = undefined;
      }
    }
    return value;
  }
  const nsigExpression = {
    type: "VariableDeclaration",
    kind: "var",
    declarations: [
      {
        type: "VariableDeclarator",
        init: {
          type: "CallExpression",
          callee: { type: "Identifier" },
          arguments: [
            { type: "Literal" },
            {
              type: "CallExpression",
              callee: { type: "Identifier", name: "decodeURIComponent" },
            },
          ],
        },
      },
    ],
  };
  const logicalExpression = {
    type: "ExpressionStatement",
    expression: {
      type: "LogicalExpression",
      left: { type: "Identifier" },
      right: {
        type: "SequenceExpression",
        expressions: [
          {
            type: "AssignmentExpression",
            left: { type: "Identifier" },
            operator: "=",
            right: {
              type: "CallExpression",
              callee: { type: "Identifier" },
              arguments: {
                or: [
                  [
                    { type: "Literal" },
                    {
                      type: "CallExpression",
                      callee: {
                        type: "Identifier",
                        name: "decodeURIComponent",
                      },
                      arguments: [{ type: "Identifier" }],
                      optional: false,
                    },
                  ],
                  [
                    {
                      type: "CallExpression",
                      callee: {
                        type: "Identifier",
                        name: "decodeURIComponent",
                      },
                      arguments: [{ type: "Identifier" }],
                      optional: false,
                    },
                  ],
                ],
              },
              optional: false,
            },
          },
          { type: "CallExpression" },
        ],
      },
      operator: "&&",
    },
  };
  const identifier$1 = {
    or: [
      {
        type: "ExpressionStatement",
        expression: {
          type: "AssignmentExpression",
          operator: "=",
          left: { type: "Identifier" },
          right: { type: "FunctionExpression", params: [{}, {}, {}] },
        },
      },
      { type: "FunctionDeclaration", params: [{}, {}, {}] },
      {
        type: "VariableDeclaration",
        declarations: {
          anykey: [
            {
              type: "VariableDeclarator",
              init: { type: "FunctionExpression", params: [{}, {}, {}] },
            },
          ],
        },
      },
    ],
  };
  function extract$1(node) {
    if (!matchesStructure(node, identifier$1)) {
      return null;
    }
    let block;
    if (
      node.type === "ExpressionStatement" &&
      node.expression.type === "AssignmentExpression" &&
      node.expression.right.type === "FunctionExpression"
    ) {
      block = node.expression.right.body;
    } else if (node.type === "VariableDeclaration") {
      for (const decl of node.declarations) {
        if (
          decl.type === "VariableDeclarator" &&
          _optionalChain([
            decl,
            "access",
            (_) => _.init,
            "optionalAccess",
            (_2) => _2.type,
          ]) === "FunctionExpression" &&
          _optionalChain([
            decl,
            "access",
            (_3) => _3.init,
            "optionalAccess",
            (_4) => _4.params,
            "access",
            (_5) => _5.length,
          ]) === 3
        ) {
          block = decl.init.body;
          break;
        }
      }
    } else if (node.type === "FunctionDeclaration") {
      block = node.body;
    } else {
      return null;
    }
    const relevantExpression = _optionalChain([
      block,
      "optionalAccess",
      (_6) => _6.body,
      "access",
      (_7) => _7.at,
      "call",
      (_8) => _8(-2),
    ]);
    let call = null;
    if (matchesStructure(relevantExpression, logicalExpression)) {
      if (
        _optionalChain([
          relevantExpression,
          "optionalAccess",
          (_9) => _9.type,
        ]) !== "ExpressionStatement" ||
        relevantExpression.expression.type !== "LogicalExpression" ||
        relevantExpression.expression.right.type !== "SequenceExpression" ||
        relevantExpression.expression.right.expressions[0].type !==
          "AssignmentExpression" ||
        relevantExpression.expression.right.expressions[0].right.type !==
          "CallExpression"
      ) {
        return null;
      }
      call = relevantExpression.expression.right.expressions[0].right;
    } else if (
      _optionalChain([
        relevantExpression,
        "optionalAccess",
        (_10) => _10.type,
      ]) === "IfStatement" &&
      relevantExpression.consequent.type === "BlockStatement"
    ) {
      for (const n of relevantExpression.consequent.body) {
        if (!matchesStructure(n, nsigExpression)) {
          continue;
        }
        if (
          n.type !== "VariableDeclaration" ||
          _optionalChain([
            n,
            "access",
            (_11) => _11.declarations,
            "access",
            (_12) => _12[0],
            "access",
            (_13) => _13.init,
            "optionalAccess",
            (_14) => _14.type,
          ]) !== "CallExpression"
        ) {
          continue;
        }
        call = n.declarations[0].init;
        break;
      }
    }
    if (call === null) {
      return null;
    }
    return {
      type: "ArrowFunctionExpression",
      params: [{ type: "Identifier", name: "sig" }],
      body: {
        type: "CallExpression",
        callee: { type: "Identifier", name: call.callee.name },
        arguments:
          call.arguments.length === 1
            ? [{ type: "Identifier", name: "sig" }]
            : [call.arguments[0], { type: "Identifier", name: "sig" }],
        optional: false,
      },
      async: false,
      expression: false,
      generator: false,
    };
  }
  const identifier = {
    or: [
      {
        type: "VariableDeclaration",
        kind: "var",
        declarations: {
          anykey: [
            {
              type: "VariableDeclarator",
              id: { type: "Identifier" },
              init: {
                type: "ArrayExpression",
                elements: [{ type: "Identifier" }],
              },
            },
          ],
        },
      },
      {
        type: "ExpressionStatement",
        expression: {
          type: "AssignmentExpression",
          left: { type: "Identifier" },
          operator: "=",
          right: {
            type: "ArrayExpression",
            elements: [{ type: "Identifier" }],
          },
        },
      },
    ],
  };
  const catchBlockBody = [
    {
      type: "ReturnStatement",
      argument: {
        type: "BinaryExpression",
        left: {
          type: "MemberExpression",
          object: { type: "Identifier" },
          computed: true,
          property: { type: "Literal" },
          optional: false,
        },
        right: { type: "Identifier" },
        operator: "+",
      },
    },
  ];
  function extract(node) {
    if (!matchesStructure(node, identifier)) {
      let name = null;
      let block = null;
      switch (node.type) {
        case "ExpressionStatement": {
          if (
            node.expression.type === "AssignmentExpression" &&
            node.expression.left.type === "Identifier" &&
            node.expression.right.type === "FunctionExpression" &&
            node.expression.right.params.length === 1
          ) {
            name = node.expression.left.name;
            block = node.expression.right.body;
          }
          break;
        }
        case "FunctionDeclaration": {
          if (node.params.length === 1) {
            name = _optionalChain([
              node,
              "access",
              (_) => _.id,
              "optionalAccess",
              (_2) => _2.name,
            ]);
            block = node.body;
          }
          break;
        }
      }
      if (!block || !name) {
        return null;
      }
      const tryNode = block.body.at(-2);
      if (
        _optionalChain([tryNode, "optionalAccess", (_3) => _3.type]) !==
          "TryStatement" ||
        _optionalChain([
          tryNode,
          "access",
          (_4) => _4.handler,
          "optionalAccess",
          (_5) => _5.type,
        ]) !== "CatchClause"
      ) {
        return null;
      }
      const catchBody = tryNode.handler.body.body;
      if (matchesStructure(catchBody, catchBlockBody)) {
        return makeSolverFuncFromName(name);
      }
      return null;
    }
    if (node.type === "VariableDeclaration") {
      for (const declaration of node.declarations) {
        if (
          declaration.type !== "VariableDeclarator" ||
          !declaration.init ||
          declaration.init.type !== "ArrayExpression" ||
          declaration.init.elements.length !== 1
        ) {
          continue;
        }
        const [firstElement] = declaration.init.elements;
        if (firstElement && firstElement.type === "Identifier") {
          return makeSolverFuncFromName(firstElement.name);
        }
      }
    } else if (node.type === "ExpressionStatement") {
      const expr = node.expression;
      if (
        expr.type === "AssignmentExpression" &&
        expr.left.type === "Identifier" &&
        expr.operator === "=" &&
        expr.right.type === "ArrayExpression" &&
        expr.right.elements.length === 1
      ) {
        const [firstElement] = expr.right.elements;
        if (firstElement && firstElement.type === "Identifier") {
          return makeSolverFuncFromName(firstElement.name);
        }
      }
    }
    return null;
  }
  function makeSolverFuncFromName(name) {
    return {
      type: "ArrowFunctionExpression",
      params: [{ type: "Identifier", name: "n" }],
      body: {
        type: "CallExpression",
        callee: { type: "Identifier", name: name },
        arguments: [{ type: "Identifier", name: "n" }],
        optional: false,
      },
      async: false,
      expression: false,
      generator: false,
    };
  }
  // Setup code injected before the player to provide browser-like globals.
  // This is a plain string to avoid re-parsing overhead.
  const setupCodeStr = `\nif (typeof globalThis.XMLHttpRequest === "undefined") {\n    globalThis.XMLHttpRequest = { prototype: {} };\n}\nconst window = Object.create(null);\nif (typeof URL === "undefined") {\n    window.location = {\n        hash: "",\n        host: "www.youtube.com",\n        hostname: "www.youtube.com",\n        href: "https://www.youtube.com/watch?v=yt-dlp-wins",\n        origin: "https://www.youtube.com",\n        password: "",\n        pathname: "/watch",\n        port: "",\n        protocol: "https:",\n        search: "?v=yt-dlp-wins",\n        username: "",\n    };\n} else {\n    window.location = new URL("https://www.youtube.com/watch?v=yt-dlp-wins");\n}\nif (typeof globalThis.document === "undefined") {\n    globalThis.document = Object.create(null);\n}\nif (typeof globalThis.navigator === "undefined") {\n    globalThis.navigator = Object.create(null);\n}\nif (typeof globalThis.self === "undefined") {\n    globalThis.self = globalThis;\n}\n`;
  function preprocessPlayer(data) {
    // === String injection approach ===
    // Instead of re-generating the entire 2.5MB player.js through astring,
    // we only generate the small solver assignments (~2KB) and inject them
    // into the original source string. This saves ~250ms of astring.generate.
    const ast = meriyah.parse(data);
    const body = ast.body;
    // Determine IIFE structure and find the block body
    let isCase2 = false;
    const block = (() => {
      switch (body.length) {
        case 1: {
          const func = body[0];
          if (
            _optionalChain([func, "optionalAccess", (_) => _.type]) ===
              "ExpressionStatement" &&
            func.expression.type === "CallExpression" &&
            func.expression.callee.type === "MemberExpression" &&
            func.expression.callee.object.type === "FunctionExpression"
          ) {
            return func.expression.callee.object.body;
          }
          break;
        }
        case 2: {
          const func = body[1];
          if (
            _optionalChain([func, "optionalAccess", (_2) => _2.type]) ===
              "ExpressionStatement" &&
            func.expression.type === "CallExpression" &&
            func.expression.callee.type === "FunctionExpression"
          ) {
            isCase2 = true;
            return func.expression.callee.body;
          }
          break;
        }
      }
      throw "unexpected structure";
    })();
    // Find solver functions by walking the AST
    const found = { n: [], sig: [] };
    for (const node of block.body) {
      const n = extract(node);
      if (n) found.n.push(n);
      const sig = extract$1(node);
      if (sig) found.sig.push(sig);
    }
    // Diagnostic: log extraction results for debugging
    console.log(
      `[yt.solver] Extraction: n=${found.n.length} candidates, sig=${found.sig.length} candidates` +
        (isCase2 ? " (case 2: dual-statement IIFE)" : " (case 1: single-statement IIFE)")
    );
    // Generate ONLY the solver assignment code (tiny ~2KB)
    const solverStmts = [];
    for (const [name, options] of Object.entries(found)) {
      if (options.length === 0) continue; // No candidates found, _result stays null
      solverStmts.push({
        type: "ExpressionStatement",
        expression: {
          type: "AssignmentExpression",
          operator: "=",
          left: {
            type: "MemberExpression",
            computed: false,
            object: { type: "Identifier", name: "_result" },
            property: { type: "Identifier", name: name },
          },
          // Single candidate: use directly (no multiTry wrapper overhead)
          // Multiple candidates: wrap in multiTry for consensus validation
          right: options.length === 1 ? options[0] : multiTry(options),
        },
      });
    }
    const solverCode = astring.generate(
      { type: "Program", body: solverStmts },
      { indent: "" },
    );
    // Find injection point: before the IIFE's closing })
    let source = data;
    const closingIdx = source.lastIndexOf("})");
    if (closingIdx === -1) throw "Cannot find IIFE closing";
    let insertPos = closingIdx;
    // For case 2: remove 'var window=this;' so setup code's window
    // definition takes effect inside the IIFE (replaces this=globalThis
    // with a controlled fake window object)
    if (isCase2) {
      const marker = "{var window=this;";
      const markerIdx = source.indexOf(marker);
      if (markerIdx !== -1) {
        source =
          source.slice(0, markerIdx + 1) +
          source.slice(markerIdx + marker.length);
        insertPos -= marker.length - 1;
      }
    }
    // Build result: setupCode + original source with solver injected
    return (
      setupCodeStr +
      source.slice(0, insertPos) +
      "\n" +
      solverCode +
      source.slice(insertPos)
    );
  }
  function multiTry(generators) {
    return {
      type: "ArrowFunctionExpression",
      params: [{ type: "Identifier", name: "_input" }],
      body: {
        type: "BlockStatement",
        body: [
          {
            type: "VariableDeclaration",
            kind: "const",
            declarations: [
              {
                type: "VariableDeclarator",
                id: { type: "Identifier", name: "_results" },
                init: {
                  type: "NewExpression",
                  callee: { type: "Identifier", name: "Set" },
                  arguments: [],
                },
              },
            ],
          },
          {
            type: "ForOfStatement",
            left: {
              type: "VariableDeclaration",
              kind: "const",
              declarations: [
                {
                  type: "VariableDeclarator",
                  id: { type: "Identifier", name: "_generator" },
                  init: null,
                },
              ],
            },
            right: {
              type: "ArrayExpression",
              elements: generators,
            },
            body: {
              type: "BlockStatement",
              body: [
                {
                  type: "TryStatement",
                  block: {
                    type: "BlockStatement",
                    body: [
                      {
                        type: "ExpressionStatement",
                        expression: {
                          type: "CallExpression",
                          callee: {
                            type: "MemberExpression",
                            object: { type: "Identifier", name: "_results" },
                            computed: false,
                            property: { type: "Identifier", name: "add" },
                            optional: false,
                          },
                          arguments: [
                            {
                              type: "CallExpression",
                              callee: {
                                type: "Identifier",
                                name: "_generator",
                              },
                              arguments: [
                                { type: "Identifier", name: "_input" },
                              ],
                              optional: false,
                            },
                          ],
                          optional: false,
                        },
                      },
                    ],
                  },
                  handler: {
                    type: "CatchClause",
                    param: null,
                    body: { type: "BlockStatement", body: [] },
                  },
                  finalizer: null,
                },
              ],
            },
            await: false,
          },
          {
            type: "IfStatement",
            test: {
              type: "UnaryExpression",
              operator: "!",
              argument: {
                type: "MemberExpression",
                object: { type: "Identifier", name: "_results" },
                computed: false,
                property: { type: "Identifier", name: "size" },
                optional: false,
              },
              prefix: true,
            },
            consequent: {
              type: "BlockStatement",
              body: [
                {
                  type: "ThrowStatement",
                  argument: {
                    type: "TemplateLiteral",
                    expressions: [],
                    quasis: [
                      {
                        type: "TemplateElement",
                        value: { cooked: "no solutions", raw: "no solutions" },
                        tail: true,
                      },
                    ],
                  },
                },
              ],
            },
            alternate: null,
          },
          {
            type: "IfStatement",
            test: {
              type: "BinaryExpression",
              left: {
                type: "MemberExpression",
                object: { type: "Identifier", name: "_results" },
                computed: false,
                property: { type: "Identifier", name: "size" },
                optional: false,
              },
              right: { type: "Literal", value: 1 },
              operator: "!==",
            },
            consequent: {
              type: "BlockStatement",
              body: [
                {
                  type: "ThrowStatement",
                  argument: {
                    type: "TemplateLiteral",
                    expressions: [
                      {
                        type: "CallExpression",
                        callee: {
                          type: "MemberExpression",
                          object: {
                            type: "CallExpression",
                            callee: {
                              type: "Identifier",
                              name: "Array",
                            },
                            arguments: [
                              {
                                type: "SpreadElement",
                                argument: {
                                  type: "Identifier",
                                  name: "_results",
                                },
                              },
                            ],
                            optional: false,
                          },
                          computed: false,
                          property: { type: "Identifier", name: "join" },
                          optional: false,
                        },
                        arguments: [{ type: "Literal", value: ", " }],
                        optional: false,
                      },
                    ],
                    quasis: [
                      {
                        type: "TemplateElement",
                        value: {
                          cooked: "invalid solutions: ",
                          raw: "invalid solutions: ",
                        },
                        tail: false,
                      },
                      {
                        type: "TemplateElement",
                        value: { cooked: "", raw: "" },
                        tail: true,
                      },
                    ],
                  },
                },
              ],
            },
            alternate: null,
          },
          {
            type: "ReturnStatement",
            argument: {
              type: "MemberExpression",
              object: {
                type: "CallExpression",
                callee: {
                  type: "MemberExpression",
                  object: {
                    type: "CallExpression",
                    callee: {
                      type: "MemberExpression",
                      object: { type: "Identifier", name: "_results" },
                      computed: false,
                      property: { type: "Identifier", name: "values" },
                      optional: false,
                    },
                    arguments: [],
                    optional: false,
                  },
                  computed: false,
                  property: { type: "Identifier", name: "next" },
                  optional: false,
                },
                arguments: [],
                optional: false,
              },
              computed: false,
              property: { type: "Identifier", name: "value" },
              optional: false,
            },
          },
        ],
      },
      async: false,
      expression: false,
      generator: false,
    };
  }
  // Cache the last executed code and its solver functions to avoid
  // re-compiling the same ~2.5MB code on repeated calls.
  let _cachedCode = null;
  let _cachedSolvers = null;
  function getFromPrepared(code) {
    if (code === _cachedCode && _cachedSolvers) return _cachedSolvers;
    const resultObj = { n: null, sig: null };
    Function("_result", code)(resultObj);
    _cachedCode = code;
    _cachedSolvers = resultObj;
    return resultObj;
  }
  function main(input) {
    const preprocessedPlayer =
      input.type === "player"
        ? preprocessPlayer(input.player)
        : input.preprocessed_player;
    const solvers = getFromPrepared(preprocessedPlayer);
    const responses = input.requests.map((input) => {
      if (!isOneOf(input.type, "n", "sig")) {
        return { type: "error", error: `Unknown request type: ${input.type}` };
      }
      const solver = solvers[input.type];
      if (!solver) {
        return {
          type: "error",
          error: `Failed to extract ${input.type} function (n=${solvers.n ? "ok" : "null"}, sig=${solvers.sig ? "ok" : "null"})`,
        };
      }
      try {
        return {
          type: "result",
          data: Object.fromEntries(
            input.challenges.map((challenge) => {
              const result = solver(challenge);
              // Validate n-sig results inside the solver itself:
              // If result ends with the challenge, the function returned an
              // error-bearing string (e.g., "enhanced_except_...CHALLENGE").
              // This is the same heuristic background.js uses, but catching
              // it here gives a clearer error and avoids false positives.
              if (
                input.type === "n" &&
                typeof result === "string" &&
                result.length > challenge.length &&
                result.endsWith(challenge)
              ) {
                throw new Error(
                  `n-sig validation failed: result ends with challenge`
                );
              }
              return [challenge, result];
            }),
          ),
        };
      } catch (error) {
        return {
          type: "error",
          error:
            error instanceof Error
              ? `${error.message}\n${error.stack}`
              : `${error}`,
        };
      }
    });
    const output = { type: "result", responses: responses };
    if (input.type === "player" && input.output_preprocessed) {
      output.preprocessed_player = preprocessedPlayer;
    }
    return output;
  }
  return main;
})(meriyah, astring);
