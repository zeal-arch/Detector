/*!
 * SPDX-License-Identifier: Unlicense
 * This file was automatically generated by https://github.com/yt-dlp/ejs
 */
var jsc = (function (meriyah, astring) {
  "use strict";
  function matchesStructure(obj, structure) {
    if (Array.isArray(structure)) {
      if (!Array.isArray(obj)) {
        return false;
      }
      return (
        structure.length === obj.length &&
        structure.every((value, index) => matchesStructure(obj[index], value))
      );
    }
    if (typeof structure === "object") {
      if (!obj) {
        return !structure;
      }
      if ("or" in structure) {
        return structure.or.some((node) => matchesStructure(obj, node));
      }
      if ("anykey" in structure && Array.isArray(structure.anykey)) {
        const haystack = Array.isArray(obj) ? obj : Object.values(obj);
        return structure.anykey.every((value) =>
          haystack.some((el) => matchesStructure(el, value)),
        );
      }
      for (const [key, value] of Object.entries(structure)) {
        if (!matchesStructure(obj[key], value)) {
          return false;
        }
      }
      return true;
    }
    return structure === obj;
  }
  function isOneOf(value, ...of) {
    return of.includes(value);
  }
  function _optionalChain(ops) {
    let lastAccessLHS = undefined;
    let value = ops[0];
    let i = 1;
    while (i < ops.length) {
      const op = ops[i];
      const fn = ops[i + 1];
      i += 2;
      if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
        return undefined;
      }
      if (op === "access" || op === "optionalAccess") {
        lastAccessLHS = value;
        value = fn(value);
      } else if (op === "call" || op === "optionalCall") {
        value = fn((...args) => value.call(lastAccessLHS, ...args));
        lastAccessLHS = undefined;
      }
    }
    return value;
  }
  const nsigExpression = {
    type: "VariableDeclaration",
    declarations: [
      {
        type: "VariableDeclarator",
        init: {
          type: "CallExpression",
          callee: { type: "Identifier" },
          arguments: [
            { type: "Literal" },
            {
              type: "CallExpression",
              callee: { type: "Identifier", name: "decodeURIComponent" },
            },
          ],
        },
      },
    ],
  };
  const logicalExpression = {
    type: "ExpressionStatement",
    expression: {
      type: "LogicalExpression",
      left: { type: "Identifier" },
      right: {
        type: "SequenceExpression",
        expressions: [
          {
            type: "AssignmentExpression",
            left: { type: "Identifier" },
            operator: "=",
            right: {
              type: "CallExpression",
              callee: { type: "Identifier" },
              arguments: {
                or: [
                  [
                    { type: "Literal" },
                    {
                      type: "CallExpression",
                      callee: {
                        type: "Identifier",
                        name: "decodeURIComponent",
                      },
                      optional: false,
                    },
                  ],
                  [
                    {
                      type: "CallExpression",
                      callee: {
                        type: "Identifier",
                        name: "decodeURIComponent",
                      },
                      optional: false,
                    },
                  ],
                ],
              },
              optional: false,
            },
          },
          { type: "CallExpression" },
        ],
      },
      operator: "&&",
    },
  };
  const identifier$1 = {
    or: [
      {
        type: "ExpressionStatement",
        expression: {
          type: "AssignmentExpression",
          operator: "=",
          left: { type: "Identifier" },
          right: {
            type: "FunctionExpression",
            params: {
              or: [
                [{}, {}, {}],
                [{}, {}, {}, {}],
              ],
            },
          },
        },
      },
      {
        type: "FunctionDeclaration",
        params: {
          or: [
            [{}, {}, {}],
            [{}, {}, {}, {}],
          ],
        },
      },
      {
        type: "VariableDeclaration",
        declarations: {
          anykey: [
            {
              type: "VariableDeclarator",
              init: {
                type: "FunctionExpression",
                params: {
                  or: [
                    [{}, {}, {}],
                    [{}, {}, {}, {}],
                  ],
                },
              },
            },
          ],
        },
      },
    ],
  };
  function extract$1(node) {
    const blocks = [];

    if (matchesStructure(node, identifier$1)) {
      if (
        node.type === "ExpressionStatement" &&
        node.expression.type === "AssignmentExpression" &&
        node.expression.right.type === "FunctionExpression" &&
        node.expression.right.params.length >= 3
      ) {
        blocks.push(node.expression.right.body);
      } else if (node.type === "VariableDeclaration") {
        for (const decl of node.declarations) {
          if (
            _optionalChain([
              decl,
              "access",
              (_) => _.init,
              "optionalAccess",
              (_2) => _2.type,
            ]) === "FunctionExpression" &&
            decl.init.params.length >= 3
          ) {
            blocks.push(decl.init.body);
          }
        }
      } else if (
        node.type === "FunctionDeclaration" &&
        node.params.length >= 3
      ) {
        blocks.push(node.body);
      } else {
        return null;
      }
    } else if (
      node.type === "ExpressionStatement" &&
      node.expression.type === "SequenceExpression"
    ) {
      for (const expr of node.expression.expressions) {
        if (
          expr.type === "AssignmentExpression" &&
          expr.right.type === "FunctionExpression" &&
          expr.right.params.length >= 3
        ) {
          blocks.push(expr.right.body);
        }
      }
    } else {
      return null;
    }

    for (const block of blocks) {
      let call = null;

      for (const stmt of block.body) {
        if (matchesStructure(stmt, logicalExpression)) {
          if (
            stmt.type === "ExpressionStatement" &&
            stmt.expression.type === "LogicalExpression" &&
            stmt.expression.right.type === "SequenceExpression" &&
            stmt.expression.right.expressions[0].type ===
              "AssignmentExpression" &&
            stmt.expression.right.expressions[0].right.type === "CallExpression"
          ) {
            call = stmt.expression.right.expressions[0].right;
            break;
          }
        } else if (stmt.type === "IfStatement") {
          let consequent = stmt.consequent;
          while (consequent.type === "LabeledStatement") {
            consequent = consequent.body;
          }

          if (consequent.type === "BlockStatement") {
            for (const n of consequent.body) {
              if (!matchesStructure(n, nsigExpression)) {
                continue;
              }

              if (
                n.type === "VariableDeclaration" &&
                _optionalChain([
                  n,
                  "access",
                  (_11) => _11.declarations,
                  "access",
                  (_12) => _12[0],
                  "optionalAccess",
                  (_13) => _13.init,
                  "optionalAccess",
                  (_14) => _14.type,
                ]) === "CallExpression"
              ) {
                call = n.declarations[0].init;
                break;
              }
            }
          }
          if (call) break;
        } else if (matchesStructure(stmt, nsigExpression)) {
          // Top-level nsigExpression: handle ES6 variants where the cipher
          // call is directly in the function body (not inside an IfStatement)
          if (
            stmt.type === "VariableDeclaration" &&
            _optionalChain([
              stmt,
              "access",
              (_20) => _20.declarations,
              "access",
              (_21) => _21[0],
              "optionalAccess",
              (_22) => _22.init,
              "optionalAccess",
              (_23) => _23.type,
            ]) === "CallExpression"
          ) {
            call = stmt.declarations[0].init;
            break;
          }
        }
      }

      if (
        _optionalChain([
          call,
          "optionalAccess",
          (_15) => _15.callee,
          "access",
          (_16) => _16.type,
        ]) !== "Identifier"
      ) {
        continue;
      }

      return {
        type: "ArrowFunctionExpression",
        params: [{ type: "Identifier", name: "sig" }],
        body: {
          type: "CallExpression",
          callee: { type: "Identifier", name: call.callee.name },
          arguments: call.arguments.map(function (arg) {
            if (
              arg.type === "CallExpression" &&
              arg.callee.type === "Identifier" &&
              arg.callee.name === "decodeURIComponent"
            ) {
              return { type: "Identifier", name: "sig" };
            }
            return arg;
          }),
          optional: false,
        },
        async: false,
        expression: false,
        generator: false,
      };
    }

    return null;
  }
  const identifier = {
    or: [
      {
        type: "VariableDeclaration",
        kind: "var",
        declarations: {
          anykey: [
            {
              type: "VariableDeclarator",
              id: { type: "Identifier" },
              init: {
                type: "ArrayExpression",
                elements: [{ type: "Identifier" }],
              },
            },
          ],
        },
      },
      {
        type: "ExpressionStatement",
        expression: {
          type: "AssignmentExpression",
          left: { type: "Identifier" },
          operator: "=",
          right: {
            type: "ArrayExpression",
            elements: [{ type: "Identifier" }],
          },
        },
      },
    ],
  };
  const catchBlockBody = [
    {
      type: "ReturnStatement",
      argument: {
        type: "BinaryExpression",
        left: {
          type: "MemberExpression",
          object: { type: "Identifier" },
          computed: true,
          property: { type: "Literal" },
          optional: false,
        },
        right: { type: "Identifier" },
        operator: "+",
      },
    },
  ];
  function extract(node) {
    if (!matchesStructure(node, identifier)) {
      let name = null;
      let block = null;
      switch (node.type) {
        case "ExpressionStatement": {
          if (
            node.expression.type === "AssignmentExpression" &&
            node.expression.left.type === "Identifier" &&
            node.expression.right.type === "FunctionExpression" &&
            node.expression.right.params.length === 1
          ) {
            name = node.expression.left.name;
            block = node.expression.right.body;
          }
          break;
        }
        case "FunctionDeclaration": {
          if (node.params.length === 1) {
            name = _optionalChain([
              node,
              "access",
              (_) => _.id,
              "optionalAccess",
              (_2) => _2.name,
            ]);
            block = node.body;
          }
          break;
        }
      }
      if (!block || !name) {
        return null;
      }
      const tryNode = block.body.at(-2);
      if (
        _optionalChain([tryNode, "optionalAccess", (_3) => _3.type]) !==
          "TryStatement" ||
        _optionalChain([
          tryNode,
          "access",
          (_4) => _4.handler,
          "optionalAccess",
          (_5) => _5.type,
        ]) !== "CatchClause"
      ) {
        return null;
      }
      const catchBody = tryNode.handler.body.body;
      if (matchesStructure(catchBody, catchBlockBody)) {
        return makeSolverFuncFromName(name);
      }
      return null;
    }
    if (node.type === "VariableDeclaration") {
      for (const declaration of node.declarations) {
        if (
          declaration.type !== "VariableDeclarator" ||
          !declaration.init ||
          declaration.init.type !== "ArrayExpression" ||
          declaration.init.elements.length !== 1
        ) {
          continue;
        }
        const [firstElement] = declaration.init.elements;
        if (firstElement && firstElement.type === "Identifier") {
          return makeSolverFuncFromName(firstElement.name);
        }
      }
    } else if (node.type === "ExpressionStatement") {
      const expr = node.expression;
      if (
        expr.type === "AssignmentExpression" &&
        expr.left.type === "Identifier" &&
        expr.operator === "=" &&
        expr.right.type === "ArrayExpression" &&
        expr.right.elements.length === 1
      ) {
        const [firstElement] = expr.right.elements;
        if (firstElement && firstElement.type === "Identifier") {
          return makeSolverFuncFromName(firstElement.name);
        }
      }
    }
    return null;
  }
  function makeSolverFuncFromName(name) {
    return {
      type: "ArrowFunctionExpression",
      params: [{ type: "Identifier", name: "n" }],
      body: {
        type: "CallExpression",
        callee: { type: "Identifier", name: name },
        arguments: [{ type: "Identifier", name: "n" }],
        optional: false,
      },
      async: false,
      expression: false,
      generator: false,
    };
  }
  // Setup code injected before the player to provide browser-like globals.
  // This is a plain string to avoid re-parsing overhead.
  const setupCodeStr = `\nif (typeof globalThis.XMLHttpRequest === "undefined") {\n    globalThis.XMLHttpRequest = { prototype: {} };\n}\nconst window = Object.create(null);\nif (typeof URL === "undefined") {\n    window.location = {\n        hash: "",\n        host: "www.youtube.com",\n        hostname: "www.youtube.com",\n        href: "https://www.youtube.com/watch?v=yt-dlp-wins",\n        origin: "https://www.youtube.com",\n        password: "",\n        pathname: "/watch",\n        port: "",\n        protocol: "https:",\n        search: "?v=yt-dlp-wins",\n        username: "",\n    };\n} else {\n    window.location = new URL("https://www.youtube.com/watch?v=yt-dlp-wins");\n}\nif (typeof globalThis.document === "undefined") {\n    globalThis.document = Object.create(null);\n}\nif (typeof globalThis.navigator === "undefined") {\n    globalThis.navigator = Object.create(null);\n}\nif (typeof globalThis.self === "undefined") {\n    globalThis.self = globalThis;\n}\n`;
  function preprocessPlayer(data) {
    // === String injection approach ===
    // Instead of re-generating the entire 2.5MB player.js through astring,
    // we only generate the small solver assignments (~2KB) and inject them
    // into the original source string. This saves ~250ms of astring.generate.
    const ast = meriyah.parse(data);
    const body = ast.body;
    // Determine IIFE structure and find the block body
    let isCase2 = false;
    const block = (() => {
      switch (body.length) {
        case 1: {
          const func = body[0];
          if (
            _optionalChain([func, "optionalAccess", (_) => _.type]) ===
              "ExpressionStatement" &&
            func.expression.type === "CallExpression" &&
            func.expression.callee.type === "MemberExpression" &&
            func.expression.callee.object.type === "FunctionExpression"
          ) {
            return func.expression.callee.object.body;
          }
          break;
        }
        case 2: {
          const func = body[1];
          if (
            _optionalChain([func, "optionalAccess", (_2) => _2.type]) ===
              "ExpressionStatement" &&
            func.expression.type === "CallExpression"
          ) {
            // Direct call: (function(){...})(this)
            if (func.expression.callee.type === "FunctionExpression") {
              isCase2 = true;
              return func.expression.callee.body;
            }
            // .call(this): 'use strict'; (function(){...}).call(this)
            // â€” the es6 variant uses this pattern
            if (
              func.expression.callee.type === "MemberExpression" &&
              func.expression.callee.object.type === "FunctionExpression"
            ) {
              isCase2 = true;
              return func.expression.callee.object.body;
            }
          }
          break;
        }
      }
      throw new Error("unexpected structure");
    })();
    // Find solver functions by walking the AST
    const found = { n: [], sig: [] };
    for (const node of block.body) {
      const n = extract(node);
      if (n) found.n.push(n);
      const sig = extract$1(node);
      if (sig) found.sig.push(sig);
    }
    // Diagnostic: log extraction results for debugging
    console.log(
      `[yt.solver] Extraction: n=${found.n.length} candidates, sig=${found.sig.length} candidates` +
        (isCase2
          ? " (case 2: dual-statement IIFE)"
          : " (case 1: single-statement IIFE)"),
    );
    // Generate ONLY the solver assignment code (tiny ~2KB)
    const solverStmts = [];
    for (const [name, options] of Object.entries(found)) {
      if (options.length === 0) continue; // No candidates found, _result stays null
      solverStmts.push({
        type: "ExpressionStatement",
        expression: {
          type: "AssignmentExpression",
          operator: "=",
          left: {
            type: "MemberExpression",
            computed: false,
            object: { type: "Identifier", name: "_result" },
            property: { type: "Identifier", name: name },
          },
          // Single candidate: use directly (no multiTry wrapper overhead)
          // Multiple candidates: wrap in multiTry for consensus validation
          right: options.length === 1 ? options[0] : multiTry(options),
        },
      });
    }
    const solverCode = astring.generate(
      { type: "Program", body: solverStmts },
      { indent: "" },
    );
    // Find injection point: before the IIFE's closing })
    let source = data;
    const closingIdx = source.lastIndexOf("})");
    if (closingIdx === -1) throw new Error("Cannot find IIFE closing");
    let insertPos = closingIdx;
    // For case 2: remove 'var window=this;' so setup code's window
    // definition takes effect inside the IIFE (replaces this=globalThis
    // with a controlled fake window object)
    if (isCase2) {
      const marker = "{var window=this;";
      const markerIdx = source.indexOf(marker);
      if (markerIdx !== -1) {
        source =
          source.slice(0, markerIdx + 1) +
          source.slice(markerIdx + marker.length);
        insertPos -= marker.length - 1;
      }
    }
    // Build result: setupCode + original source with solver injected
    return (
      setupCodeStr +
      source.slice(0, insertPos) +
      "\n" +
      solverCode +
      source.slice(insertPos)
    );
  }
  function multiTry(generators) {
    return {
      type: "ArrowFunctionExpression",
      params: [{ type: "Identifier", name: "_input" }],
      body: {
        type: "BlockStatement",
        body: [
          {
            type: "VariableDeclaration",
            kind: "const",
            declarations: [
              {
                type: "VariableDeclarator",
                id: { type: "Identifier", name: "_results" },
                init: {
                  type: "NewExpression",
                  callee: { type: "Identifier", name: "Set" },
                  arguments: [],
                },
              },
            ],
          },
          {
            type: "ForOfStatement",
            left: {
              type: "VariableDeclaration",
              kind: "const",
              declarations: [
                {
                  type: "VariableDeclarator",
                  id: { type: "Identifier", name: "_generator" },
                  init: null,
                },
              ],
            },
            right: {
              type: "ArrayExpression",
              elements: generators,
            },
            body: {
              type: "BlockStatement",
              body: [
                {
                  type: "TryStatement",
                  block: {
                    type: "BlockStatement",
                    body: [
                      {
                        type: "ExpressionStatement",
                        expression: {
                          type: "CallExpression",
                          callee: {
                            type: "MemberExpression",
                            object: { type: "Identifier", name: "_results" },
                            computed: false,
                            property: { type: "Identifier", name: "add" },
                            optional: false,
                          },
                          arguments: [
                            {
                              type: "CallExpression",
                              callee: {
                                type: "Identifier",
                                name: "_generator",
                              },
                              arguments: [
                                { type: "Identifier", name: "_input" },
                              ],
                              optional: false,
                            },
                          ],
                          optional: false,
                        },
                      },
                    ],
                  },
                  handler: {
                    type: "CatchClause",
                    param: null,
                    body: { type: "BlockStatement", body: [] },
                  },
                  finalizer: null,
                },
              ],
            },
            await: false,
          },
          {
            type: "IfStatement",
            test: {
              type: "UnaryExpression",
              operator: "!",
              argument: {
                type: "MemberExpression",
                object: { type: "Identifier", name: "_results" },
                computed: false,
                property: { type: "Identifier", name: "size" },
                optional: false,
              },
              prefix: true,
            },
            consequent: {
              type: "BlockStatement",
              body: [
                {
                  type: "ThrowStatement",
                  argument: {
                    type: "TemplateLiteral",
                    expressions: [],
                    quasis: [
                      {
                        type: "TemplateElement",
                        value: { cooked: "no solutions", raw: "no solutions" },
                        tail: true,
                      },
                    ],
                  },
                },
              ],
            },
            alternate: null,
          },
          {
            type: "IfStatement",
            test: {
              type: "BinaryExpression",
              left: {
                type: "MemberExpression",
                object: { type: "Identifier", name: "_results" },
                computed: false,
                property: { type: "Identifier", name: "size" },
                optional: false,
              },
              right: { type: "Literal", value: 1 },
              operator: "!==",
            },
            consequent: {
              type: "BlockStatement",
              body: [
                {
                  type: "ThrowStatement",
                  argument: {
                    type: "TemplateLiteral",
                    expressions: [
                      {
                        type: "CallExpression",
                        callee: {
                          type: "MemberExpression",
                          object: {
                            type: "CallExpression",
                            callee: {
                              type: "Identifier",
                              name: "Array",
                            },
                            arguments: [
                              {
                                type: "SpreadElement",
                                argument: {
                                  type: "Identifier",
                                  name: "_results",
                                },
                              },
                            ],
                            optional: false,
                          },
                          computed: false,
                          property: { type: "Identifier", name: "join" },
                          optional: false,
                        },
                        arguments: [{ type: "Literal", value: ", " }],
                        optional: false,
                      },
                    ],
                    quasis: [
                      {
                        type: "TemplateElement",
                        value: {
                          cooked: "invalid solutions: ",
                          raw: "invalid solutions: ",
                        },
                        tail: false,
                      },
                      {
                        type: "TemplateElement",
                        value: { cooked: "", raw: "" },
                        tail: true,
                      },
                    ],
                  },
                },
              ],
            },
            alternate: null,
          },
          {
            type: "ReturnStatement",
            argument: {
              type: "MemberExpression",
              object: {
                type: "CallExpression",
                callee: {
                  type: "MemberExpression",
                  object: {
                    type: "CallExpression",
                    callee: {
                      type: "MemberExpression",
                      object: { type: "Identifier", name: "_results" },
                      computed: false,
                      property: { type: "Identifier", name: "values" },
                      optional: false,
                    },
                    arguments: [],
                    optional: false,
                  },
                  computed: false,
                  property: { type: "Identifier", name: "next" },
                  optional: false,
                },
                arguments: [],
                optional: false,
              },
              computed: false,
              property: { type: "Identifier", name: "value" },
              optional: false,
            },
          },
        ],
      },
      async: false,
      expression: false,
      generator: false,
    };
  }
  // Cache the last executed code and its solver functions to avoid
  // re-compiling the same ~2.5MB code on repeated calls.
  let _cachedCode = null;
  let _cachedSolvers = null;
  function getFromPrepared(code) {
    if (code === _cachedCode && _cachedSolvers) return _cachedSolvers;
    const resultObj = { n: null, sig: null };
    Function("_result", code)(resultObj);
    _cachedCode = code;
    _cachedSolvers = resultObj;
    return resultObj;
  }
  function main(input) {
    const preprocessedPlayer =
      input.type === "player"
        ? preprocessPlayer(input.player)
        : input.preprocessed_player;
    const solvers = getFromPrepared(preprocessedPlayer);
    const responses = input.requests.map((input) => {
      if (!isOneOf(input.type, "n", "sig")) {
        return { type: "error", error: `Unknown request type: ${input.type}` };
      }
      const solver = solvers[input.type];
      if (!solver) {
        return {
          type: "error",
          error: `Failed to extract ${input.type} function (n=${solvers.n ? "ok" : "null"}, sig=${solvers.sig ? "ok" : "null"})`,
        };
      }
      try {
        return {
          type: "result",
          data: Object.fromEntries(
            input.challenges.map((challenge) => {
              const result = solver(challenge);
              // Validate n-sig results inside the solver itself:
              // If result ends with the challenge, the function returned an
              // error-bearing string (e.g., "enhanced_except_...CHALLENGE").
              // This is the same heuristic background.js uses, but catching
              // it here gives a clearer error and avoids false positives.
              if (
                input.type === "n" &&
                typeof result === "string" &&
                result.length > challenge.length &&
                result.endsWith(challenge)
              ) {
                throw new Error(
                  `n-sig validation failed: result ends with challenge`,
                );
              }
              return [challenge, result];
            }),
          ),
        };
      } catch (error) {
        return {
          type: "error",
          error:
            error instanceof Error
              ? `${error.message}\n${error.stack}`
              : `${error}`,
        };
      }
    });
    const output = { type: "result", responses: responses };
    if (input.type === "player" && input.output_preprocessed) {
      output.preprocessed_player = preprocessedPlayer;
    }
    return output;
  }
  return main;
})(meriyah, astring);
